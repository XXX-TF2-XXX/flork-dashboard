<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Donate for Multiplier</title>
  <style>
    body { margin: 0; background: transparent; }
    #connectBtn { background: #00ffff; color: #1a1a2e; padding: 12px 24px; border: none; border-radius: 8px; cursor: pointer; font-size: 1.2em; margin: 10px 0; display: none; }
    #disconnectBtn { background: #ff0055; color: white; padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9em; margin-left: 10px; }
    @media (max-width: 480px) { #connectBtn { width: 100%; } }
  </style>
</head>
<body>
<div style="background:#1a1a2e;color:#00ff9d;padding:20px;border-radius:16px;font-family:'Courier New',monospace;box-shadow:0 0 30px rgba(0,255,157,0.4);max-width:600px;margin:0 auto;text-align:center;">
<h3 style="color:#ff00ff;">Donate SOL for Multiplier Boost ðŸ§™</h3>
<button id="connectBtn">Connect Mobile Wallet</button>
<button id="disconnectBtn" style="display:none;">Disconnect</button>
<button id="donateBtn" style="background:#ff00ff;color:white;padding:16px 32px;border:none;border-radius:12px;cursor:pointer;font-size:1.4em;margin:20px 0;">Donate for Multiplier</button>
<p id="multiplierHud" style="font-size:1.6em;color:#00ffff;margin:20px 0;">Multiplier: Loading...</p>
<p style="font-size:0.9em;opacity:0.8;">0.01 SOL = +1x | Prize pool: 7UGbPH6hpRD6oW7sUtwXRYwXdBzYZAr4WWrAvobvs84R</p>
</div>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
<script src="https://unpkg.com/tweetnacl@1.0.3/nacl.min.js"></script>
<script>
const { createClient } = supabase;
const supabaseClient = createClient('https://agoaalstlgbsbymuyemx.supabase.co', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFnb2FhbHN0bGdic2J5bXV5ZW14Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU5MzY0OTIsImV4cCI6MjA4MTUxMjQ5Mn0.t-DSuGGo-wIPj8Wc4U_408D49nvyDdcI7BTA0ab6u6c');
const multiplierHud = document.getElementById('multiplierHud');
const prizePool = '7UGbPH6hpRD6oW7sUtwXRYwXdBzYZAr4WWrAvobvs84R';
const donateBtn = document.getElementById('donateBtn');
const connectBtn = document.getElementById('connectBtn');
const disconnectBtn = document.getElementById('disconnectBtn');

// Mobile detection
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

// Storage keys
const STORAGE = {
  dappPublicKey: 'flork_dappPublicKey',
  dappSecretKey: 'flork_dappSecretKey',
  walletPubKey: 'flork_walletPubKey',
  session: 'flork_session',
  sharedSecret: 'flork_sharedSecret',
  walletType: 'flork_walletType'
};

// Crypto utils
const nacl = window.nacl;
const bs58 = solanaWeb3.bs58;

function encryptPayload(payload, sharedSecret) {
  const nonce = nacl.randomBytes(nacl.box.nonceLength);
  const messageUint8 = new TextEncoder().encode(JSON.stringify(payload));
  const encrypted = nacl.box.after(messageUint8, nonce, sharedSecret);
  return { nonce, encrypted: new Uint8Array(encrypted) };
}

function decryptPayload(encryptedB58, nonceB58, sharedSecret) {
  const encrypted = bs58.decode(encryptedB58);
  const nonce = bs58.decode(nonceB58);
  const decrypted = nacl.box.open.after(encrypted, nonce, sharedSecret);
  if (!decrypted) throw new Error('Decryption failed');
  return JSON.parse(new TextDecoder().decode(decrypted));
}

function loadStoredData() {
  return {
    dappPublicKey: localStorage.getItem(STORAGE.dappPublicKey),
    dappSecretKey: localStorage.getItem(STORAGE.dappSecretKey),
    walletPubKey: localStorage.getItem(STORAGE.walletPubKey),
    session: localStorage.getItem(STORAGE.session),
    sharedSecret: localStorage.getItem(STORAGE.sharedSecret),
    walletType: localStorage.getItem(STORAGE.walletType)
  };
}

function clearStoredData() {
  Object.values(STORAGE).forEach(key => localStorage.removeItem(key));
}

function saveStoredData(data) {
  Object.entries(data).forEach(([key, value]) => {
    if (value !== undefined) localStorage.setItem(key, value);
  });
}

function generateDappKeyPair() {
  const keyPair = nacl.box.keyPair();
  const publicKey = bs58.encode(keyPair.publicKey);
  const secretKey = bs58.encode(keyPair.secretKey);
  saveStoredData({ dappPublicKey: publicKey, dappSecretKey: secretKey });
  return { publicKey, secretKey: keyPair.secretKey };
}

function getDappKeyPair() {
  const stored = loadStoredData();
  if (stored.dappPublicKey && stored.dappSecretKey) {
    return {
      publicKey: stored.dappPublicKey,
      secretKey: bs58.decode(stored.dappSecretKey)
    };
  }
  return generateDappKeyPair();
}

function isConnected() {
  const stored = loadStoredData();
  return !!stored.walletPubKey && !!stored.session && !!stored.sharedSecret;
}

function getWalletBase(walletType) {
  return walletType === 'phantom' ? 'https://phantom.app' : 'https://solflare.com';
}

function getEncParamName(walletType) {
  return walletType === 'phantom' ? 'dapp_encryption_public_key' : 'dapp_encryption_public_key'; // Solflare uses same
}

function buildConnectUrl(walletType) {
  const { publicKey } = getDappKeyPair();
  const cluster = 'mainnet-beta';
  const dappUrl = encodeURIComponent(window.location.href);
  const redirectLink = encodeURIComponent(window.location.href.split('?')[0] + '?connect_callback=true&wallet=' + walletType);
  const params = new URLSearchParams({
    dapp_encryption_public_key: publicKey,
    cluster,
    dapp_url: dappUrl,
    redirect_link: redirectLink
  });
  console.log('Launching connect deep link for', walletType, ':', `${getWalletBase(walletType)}/ul/v1/connect?${params.toString()}`);
  return `${getWalletBase(walletType)}/ul/v1/connect?${params.toString()}`;
}

async function processConnectCallback() {
  const urlParams = new URLSearchParams(window.location.search);
  if (!urlParams.has('connect_callback=true')) return false;
  const walletType = urlParams.get('wallet');
  if (!walletType) return false;
  const encParamName = getEncParamName(walletType);
  const encPubKeyB58 = urlParams.get(encParamName);
  const nonceB58 = urlParams.get('nonce');
  const dataB58 = urlParams.get('data');
  if (!encPubKeyB58 || !nonceB58 || !dataB58) {
    console.error('Missing callback data');
    alert('Connection failed: Incomplete response from wallet');
    return true;
  }
  try {
    const { secretKey } = getDappKeyPair();
    const walletEncPubKey = bs58.decode(encPubKeyB58);
    const sharedSecret = nacl.box.before(walletEncPubKey, secretKey);
    const decrypted = decryptPayload(dataB58, nonceB58, sharedSecret);
    const { public_key: walletPubKey, session } = decrypted;
    saveStoredData({ 
      walletPubKey, 
      session, 
      sharedSecret: bs58.encode(sharedSecret), 
      walletType 
    });
    console.log('Connected successfully:', walletPubKey);
    alert(`Connected with ${walletType.charAt(0).toUpperCase() + walletType.slice(1)}!`);
    return true;
  } catch (err) {
    console.error('Connect decryption failed:', err);
    alert('Connection failed: ' + err.message);
    return true;
  }
}

function buildSignUrl(walletType, serializedTx, session, sharedSecretUint8) {
  const { publicKey } = getDappKeyPair();
  const payload = { transaction: bs58.encode(serializedTx), session };
  const { nonce, encrypted } = encryptPayload(payload, sharedSecretUint8);
  const redirectLink = encodeURIComponent(window.location.href.split('?')[0] + '?sign_callback=true&wallet=' + walletType);
  const params = new URLSearchParams({
    dapp_encryption_public_key: publicKey,
    nonce: bs58.encode(nonce),
    redirect_link,
    payload: bs58.encode(encrypted)
  });
  const url = `${getWalletBase(walletType)}/ul/v1/signAndSendTransaction?${params.toString()}`;
  console.log('Launching sign deep link:', url);
  return url;
}

async function processSignCallback() {
  const urlParams = new URLSearchParams(window.location.search);
  if (!urlParams.has('sign_callback=true')) return false;
  const walletType = urlParams.get('wallet');
  if (!walletType) return false;
  const signature = urlParams.get('tx_signature');
  const errorCode = urlParams.get('errorCode');
  const errorMessage = urlParams.get('errorMessage');
  if (errorCode || errorMessage) {
    console.error('Sign error:', errorMessage);
    alert(`Transaction rejected: ${errorMessage || 'Unknown error'}`);
    return true;
  }
  if (!signature) {
    alert('Transaction failed: No signature received');
    return true;
  }
  try {
    const amount = parseFloat(localStorage.getItem('temp_donate_amount') || '0');
    localStorage.removeItem('temp_donate_amount');
    const stored = loadStoredData();
    const wallet = stored.walletPubKey;
    const { data: existing } = await supabaseClient
      .from('donations')
      .select('total_sol, tx_ids')
      .eq('wallet', wallet)
      .maybeSingle();
    const currentTotal = existing?.total_sol || 0;
    const currentTxs = existing?.tx_ids || [];
    currentTxs.push(signature);
    const { error } = await supabaseClient
      .from('donations')
      .upsert({
        wallet,
        total_sol: currentTotal + amount,
        tx_ids: currentTxs
      });
    if (error) throw error;
    console.log('Donation upserted:', signature);
    alert(`Success! Donated ${amount} SOL. Tx: https://solscan.io/tx/${signature}`);
    await loadMultiplier();
    return true;
  } catch (err) {
    console.error('Sign upsert failed:', err);
    alert('Donation recorded but DB update failedâ€”retry or contact support');
    return true;
  }
}

// Clean URL after callback
function cleanUrl() {
  if (window.history.replaceState) {
    const cleanPath = window.location.pathname + window.location.hash;
    window.history.replaceState(null, '', cleanPath);
  }
}

function getUsername() {
  let username = localStorage.getItem('florkUsername');
  if (!username) {
    username = prompt('Pick a username for leaderboard:', 'Raider' + Math.floor(Math.random() * 1000));
    if (username) localStorage.setItem('florkUsername', username.trim() || 'Anonymous');
  }
}

async function loadMultiplier() {
  multiplierHud.textContent = 'Multiplier: Loading...';
  let pubKey;
  const stored = loadStoredData();
  if (!isMobile) {
    // Desktop: Phantom extension
    if (!window.solana?.isPhantom) {
      multiplierHud.textContent = 'Multiplier: 1x (Install Phantom)';
      return;
    }
    try {
      await window.solana.connect({ onlyIfTrusted: true }).catch(() => {});
      if (!window.solana.publicKey) {
        multiplierHud.textContent = 'Multiplier: 1x (Connect Phantom)';
        return;
      }
      pubKey = window.solana.publicKey.toString();
    } catch (err) {
      console.error('Desktop connect failed:', err);
      multiplierHud.textContent = 'Multiplier: 1x';
      return;
    }
  } else {
    // Mobile: Stored session
    if (isConnected()) {
      pubKey = stored.walletPubKey;
      connectBtn.style.display = 'none';
      disconnectBtn.style.display = 'inline';
    } else {
      multiplierHud.textContent = 'Multiplier: 1x (Connect Wallet)';
      connectBtn.style.display = 'block';
      return;
    }
  }
  try {
    const { data } = await supabaseClient
      .from('donations')
      .select('total_sol')
      .eq('wallet', pubKey)
      .maybeSingle();
    const multiplier = data ? Math.floor(data.total_sol / 0.01) + 1 : 1;
    multiplierHud.textContent = `Multiplier: ${multiplier}x`;
    window.parent.postMessage({ type: 'multiplierUpdate', multiplier }, '*');
  } catch (err) {
    console.error('Multiplier load failed:', err);
    multiplierHud.textContent = 'Multiplier: 1x';
  }
}

window.addEventListener('message', (e) => {
  if (e.data.type === 'gameStatus') {
    const isActive = e.data.status === 'started';
    donateBtn.disabled = isActive;
    donateBtn.textContent = isActive ? 'Donate (Game Active)' : 'Donate for Multiplier';
    donateBtn.style.opacity = isActive ? '0.5' : '1';
  }
});

connectBtn.onclick = () => {
  const choice = prompt('Which wallet? (type "phantom" or "solflare")', 'phantom').toLowerCase().trim();
  if (!['phantom', 'solflare'].includes(choice)) {
    alert('Invalid choiceâ€”try again!');
    return;
  }
  window.location.href = buildConnectUrl(choice);
};

disconnectBtn.onclick = () => {
  if (confirm('Disconnect wallet?')) {
    clearStoredData();
    connectBtn.style.display = 'block';
    disconnectBtn.style.display = 'none';
    loadMultiplier();
  }
};

donateBtn.onclick = async () => {
  if (donateBtn.disabled) return alert('Donate before starting the raid!');
  getUsername();
  const amountStr = prompt('SOL to donate (0.01 = +1x):', '0.01');
  const amount = parseFloat(amountStr);
  if (isNaN(amount) || amount < 0.01) return alert('Minimum 0.01 SOL required!');
  let wallet, sig;
  try {
    if (!isMobile) {
      // Desktop flow (unchanged)
      if (!window.solana?.isPhantom) return alert('Phantom wallet not detected');
      await window.solana.connect({ onlyIfTrusted: false });
      wallet = window.solana.publicKey.toString();
      const connection = new solanaWeb3.Connection('https://mainnet.helius-rpc.com/?api-key=4b018f03-1fdd-4122-bc87-d73248e492d3');
      const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();
      const tx = new solanaWeb3.Transaction();
      tx.feePayer = window.solana.publicKey;
      tx.recentBlockhash = blockhash;
      tx.add(solanaWeb3.ComputeBudgetProgram.setComputeUnitPrice({ microLamports: 50000 }));
      tx.add(
        solanaWeb3.SystemProgram.transfer({
          fromPubkey: window.solana.publicKey,
          toPubkey: new solanaWeb3.PublicKey(prizePool),
          lamports: Math.floor(amount * solanaWeb3.LAMPORTS_PER_SOL)
        })
      );
      const signed = await window.solana.signTransaction(tx);
      sig = await connection.sendRawTransaction(signed.serialize(), { maxRetries: 10 });
      await connection.confirmTransaction({ signature: sig, blockhash, lastValidBlockHeight });
      // Upsert
      const { data: existing } = await supabaseClient
        .from('donations')
        .select('total_sol, tx_ids')
        .eq('wallet', wallet)
        .maybeSingle();
      const currentTotal = existing?.total_sol || 0;
      const currentTxs = existing?.tx_ids || [];
      currentTxs.push(sig);
      const { error } = await supabaseClient
        .from('donations')
        .upsert({
          wallet,
          total_sol: currentTotal + amount,
          tx_ids: currentTxs
        });
      if (error) throw error;
      alert(`Success! Donated ${amount} SOL. Tx: https://solscan.io/tx/${sig}`);
    } else {
      // Mobile flow
      if (!isConnected()) return alert('Please connect your wallet first!');
      const stored = loadStoredData();
      const sharedSecretUint8 = bs58.decode(stored.sharedSecret);
      const connection = new solanaWeb3.Connection('https://mainnet.helius-rpc.com/?api-key=4b018f03-1fdd-4122-bc87-d73248e492d3');
      const { blockhash } = await connection.getLatestBlockhash();
      const tx = new solanaWeb3.Transaction();
      tx.feePayer = new solanaWeb3.PublicKey(stored.walletPubKey);
      tx.recentBlockhash = blockhash;
      tx.add(solanaWeb3.ComputeBudgetProgram.setComputeUnitPrice({ microLamports: 50000 }));
      tx.add(
        solanaWeb3.SystemProgram.transfer({
          fromPubkey: new solanaWeb3.PublicKey(stored.walletPubKey),
          toPubkey: new solanaWeb3.PublicKey(prizePool),
          lamports: Math.floor(amount * solanaWeb3.LAMPORTS_PER_SOL)
        })
      );
      const serializedTx = tx.serialize({ requireAllSignatures: false });
      const signUrl = buildSignUrl(stored.walletType, serializedTx, stored.session, sharedSecretUint8);
      localStorage.setItem('temp_donate_amount', amount.toString());
      window.location.href = signUrl;
      return; // Exit earlyâ€”callback handles rest
    }
    await loadMultiplier();
  } catch (err) {
    console.error('Donation failed:', err);
    alert('Donation failed: ' + (err.message || 'Check console'));
  }
};

// Init: Process callbacks first
(async () => {
  const processed = await processConnectCallback() || await processSignCallback();
  if (processed) {
    cleanUrl();
    await loadMultiplier();
  } else {
    await loadMultiplier();
  }
})();
</script>
</body>
</html>
